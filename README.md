# mongo-agg-graph-descend

Provides a JavaScript function to generate a MongoDB Aggregation expression which will descend through a document's nested fields collecting each sub-document into a flattened array of elements in the result. It is analogous to MongoDB's _$graphLookup_ aggregation stage, but operates on each self-contained document in isolation rather than linking different documents together. You can think of this function as the "flatten document" function. Most of the function's parameters match the parameters for _$graphLookup_. Currently the function only supports MongoDB version 5+ due to the use of the new _$getField_ operator. However, for earlier versions of MongoDB you can replace _$getField_ in this function's code with [@asya999](https://twitter.com/asya999)'s [getField() function](https://github.com/asya999/bits-n-pieces/blob/master/scripts/getField.js) which performs the equivalent in older versions of MongoDB.

For example, imagine there is a MongoDB collection containing documents similar to the following: 

```javascript
{
  elmntId: '0',
  val: 999,
  properties: [
    {
      elmntId: '0.0',
      val: 111,
      children: [
        { elmntId: '0.0.0', val: 123 },
        { elmntId: '0.0.1', val: 456, children: 5 },
        {
          elmntId: '0.0.2',
          val: 456,
          children: [
            { elmntId: '0.0.2.0', val: 333 },
            { elmntId: '0.0.2.1', val: 222, children: 'it' },
            { elmntId: '0.0.2.2', val: 111, children: [] }
          ]
        }
      ]
    },
    {
      elmntId: '0.1',
      val: 222,
      children: [
        { elmntId: '0.1.0', val: 789, children: { x: 1 } },
        { elmntId: '0.1.1', val: 120, children: [] },
        { elmntId: '0.1.2', val: 22, children: null }
      ]
    }
  ]
}
```

Executing an aggregation pipeline which performs a _$set/$addFields/$project_ operation using the expression generated by the _graphDescend()_ function and which will output documents similar to the one shown below.

```javascript
{result: [
  { _ord: 0, _depth: 0, _idx: '0', elmntId: '0', val: 999 },
  { _ord: 1, _depth: 1, _idx: '0_0', elmntId: '0.0', val: 111 },
  { _ord: 2, _depth: 1, _idx: '0_1', elmntId: '0.1', val: 222 },
  { _ord: 3, _depth: 2, _idx: '0_0_0', elmntId: '0.0.0', val: 123 },
  { _ord: 4, _depth: 2, _idx: '0_0_1', elmntId: '0.0.1', val: 456 },
  { _ord: 5, _depth: 2, _idx: '0_0_2', elmntId: '0.0.2', val: 456 },
  { _ord: 6, _depth: 2, _idx: '0_1_0', elmntId: '0.1.0', val: 789 },
  { _ord: 7, _depth: 2, _idx: '0_1_1', elmntId: '0.1.1', val: 120 },
  { _ord: 8, _depth: 2, _idx: '0_1_2', elmntId: '0.1.2', val: 22 },
  { _ord: 9, _depth: 3, _idx: '0_0_2_0', elmntId: '0.0.2.0', val: 333 },
  { _ord: 10, _depth: 3, _idx: '0_0_2_1', elmntId: '0.0.2.1', val: 222 },
  { _ord: 11, _depth: 3, _idx: '0_0_2_2', elmntId: '0.0.2.2', val: 111 }
]}
```

To test this function, use the [MongoDB Shell](https://docs.mongodb.com/mongodb-shell/) to connect to an existing MongoDB database (with full read/write privileges) and run the following...


## Sample Data Population

Drop any old version of the database (if it exists) and then populate a new collection with a new documents containing a hierarchy of nested sub-documents.

```javascript
use mongo-agg-graph-descend-example;
db.dropDatabase();

db.mydata.insertMany([
  {
    "elmntId": "0",
    "val": 999,
    "properties": [
      {
        "elmntId": "0.0",
        "val": 111,
        "children": [
          {
            "elmntId": "0.0.0",
            "val": 123,
          },
          {
            "elmntId": "0.0.1",
            "val": 456,
            "children": 5,
          },
          {
            "elmntId": "0.0.2",
            "val": 456,
            "children": [
              {
                "elmntId": "0.0.2.0",
                "val": 333,
              },
              {
                "elmntId": "0.0.2.1",
                "val": 222,
                "children": "it",
              },
              {
                "elmntId": "0.0.2.2",
                "val": 111,
                "children": [],
              },
            ]
          },
        ]        
      },
      {
        "elmntId": "0.1",
        "val": 222,
        "children": [
          {
            "elmntId": "0.1.0",
            "val": 789,
            "children": {"x": 1},
          },
          {
            "elmntId": "0.1.1",
            "val": 120,
            "children": [],
          },
          {
            "elmntId": "0.1.2",
            "val": 22,
            "children": null,
          },
        ]        
      } 
    ]
  },
  
  {
    "elmntId": "0",
    "val": "abc",
    "otherval": false,
    "properties": [
      {
        "elmntId": "0.0",
        "val": "xyz",
        "otherval": true,
        "children": [],
      } 
    ]
  },
]);
```

## Define The 'graphDescend' Function

Load the graphDescend() function definition into the MongoDB Shell ready to be used by an aggregation pipeline. To do this for simple prototyping, copy the content of the file `graph-descend.js` from the root of this project into your clipboard and then paste it into the `mongosh` shell, ensuring that the shell accepted this new function with no errors.


## Perform First Simple Test

Define a single pipeline to perform the aggregation and then execute the pipeline:

```javascript
var pipeline = [
  {"$set": {
    "outputExample": graphDescend("children", "properties"),
  }},
];

db.mydata.aggregate(pipeline);
```

## Perform Some Other Simple Tests

Define a pipeline which will test `graphDescend()` with other parameters to see how the behaviour changes and execute it:

```javascript
var pipeline = [
  {"$set": {
    "outputExample1": graphDescend("children", "properties", 5),
    "outputExample2": graphDescend("children", "properties", 25, ["_id", "val"]),
    "outputExample3": graphDescend("children", "properties", 25, [], 1),
  }},
];
db.mydata.aggregate(pipeline);
```


## Perform Schema Analysis Example Test

Define a pipeline to use `graphDescend()` to capture the schema for collectionsand execute it:

```javascript
var pipeline = [
   // Only sample a subset of docs cos schema analysis may be too slow for very large collections
   {"$sample": {"size": 100}},
   
  // Build array of levels metadata
  {"$project": {
    "output": graphDescend("children", "properties", 25, ["_id", "elmntId", "val"], 100, true),
  }},

  // Unpack each result array member
  {"$unwind": {
    "path": "$output.result",
  }},  

  // Unpack each schema array member
  {"$unwind": {
    "path": "$output.result.schema",
  }},  

  // Group by depth and field name capturing the schema types for each
  {"$group": {
    "_id": {"depth": "$output.result._depth", "fieldname": "$output.result.schema.fieldname"},
    "types": {"$addToSet": "$output.result.schema.type"},
  }},  

  // Sort by field name
  {"$sort": {
    "_id.fieldname": 1,
  }},     

  // Group by depth capturing arrayy of each fieldname and its types
  {"$group": {
    "_id": "$_id.depth",
    "fields": {"$push": {"fieldname": "$_id.fieldname", "types": "$types"}},
  }},  

  // Clean up element nams for the final output
  {"$set": {
    "depth": "$_id",
    "schema": "$fields",
    "_id": "$$REMOVE",
    "fields": "$$REMOVE",
  }},  

  // Sort by depth 
  {"$sort": {
    "depth": 1,
  }},     
];
db.mydata.aggregate(pipeline);
```

For the sample data, this should yield the following output:

```
[
  {
    depth: 0,
    schema: [
      { fieldname: '_id', types: [ 'objectId' ] },
      { fieldname: 'elmntId', types: [ 'string' ] },
      { fieldname: 'otherval', types: [ 'bool' ] },
      { fieldname: 'properties', types: [ 'array' ] },
      { fieldname: 'val', types: [ 'int', 'string' ] }
    ]
  },
  {
    depth: 1,
    schema: [
      { fieldname: 'children', types: [ 'array' ] },
      { fieldname: 'elmntId', types: [ 'string' ] },
      { fieldname: 'otherval', types: [ 'bool' ] },
      { fieldname: 'val', types: [ 'string', 'int' ] }
    ]
  },
  {
    depth: 2,
    schema: [
      { fieldname: 'children', types: [ 'null', 'int', 'array', 'object' ] },
      { fieldname: 'elmntId', types: [ 'string' ] },
      { fieldname: 'val', types: [ 'int' ] }
    ]
  },
  {
    depth: 3,
    schema: [
      { fieldname: 'children', types: [ 'array', 'string' ] },
      { fieldname: 'elmntId', types: [ 'string' ] },
      { fieldname: 'val', types: [ 'int' ] }
    ]
  }
]
```
_NOTE_: This example only descends each document's hierarchy via the specifically named array field at each level. To descend through any and all array sub-elements, at each level, regardless of their fieldnames, `grephDescend()` would need to be enhanced a little (see _Possible Future Enhancements_ below).


## Possible Future Enhancements
* Provide an example that works for MongoDB versions before 5.0
* Implement an optional parameter which is the equivalent of "restrictSearchWithMatch" used in _$graphLookup_
* Provide an optional parameter to indicate to descend through all sub-document arrays, not just the array fields with the specified fixed name

